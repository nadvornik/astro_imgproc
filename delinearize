#!/usr/bin/python3

# Copyright (C) 2017 Vladimir Nadvornik
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.


import numpy as np
import cv2

import tifffile
import argparse
import sys
from astro_utils import normalize, noise_level
from guided_filter import *


def filt_param(s):
    try:
        r, s = s.split(',')
        return int(r), float(s)
    except:
        raise argparse.ArgumentTypeError("Filter param must be r,s")


parser = argparse.ArgumentParser()
parser.add_argument("outfile",
                    help="output tiff file")
parser.add_argument("infile",
                    help="input tiff file")

parser.add_argument('--zero', type=int, default = 0,
                   help='output zero level')

parser.add_argument("--outgamma", type=float, default=0.0,
                    help="output file gamma")

parser.add_argument("--sigmaeps", type=float, default=1.0,
                    help="output epsilon")
                    

parser.add_argument("--sigma", type=float, default=0,
                    help="sigma")


parser.add_argument("--gf1", type=filt_param, default='0,0',
                    help="filter 1 param (3,1)")

parser.add_argument("--gf2", type=filt_param, default='0,0',
                    help="filter 2 param (10,1)")

parser.add_argument("--starproc", action='store_true', default=False,
                    help="separate stars processing")


parser.add_argument("--edges", type=float, default=1.0,
                    help="edge weight")

parser.add_argument("--normalize", action='store_true', default=False)


args = parser.parse_args()


def separate_bg(img, er = 25, dil = 3):
	filt_bg = GuidedFilter(np.mean(img, axis =2),  5, 1.0 / 65536.0**2)


	bg = cv2.dilate(img, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (dil, dil)))
	bg = cv2.erode(bg, cv2.getStructuringElement(cv2.MORPH_CROSS, (er, er)))
	bg = cv2.dilate(bg, cv2.getStructuringElement(cv2.MORPH_CROSS, (er - dil, er - dil)))

	bg = filt_bg.filter(bg)
	
	stars = img - bg
	noise = noise_level(stars)
	stars[np.where(stars < noise * 2)] = 0
	
	bg = filt_bg.filter(img - stars)
	stars = img - bg
	stars[np.where(stars < 0)] = 0
	bg = img - stars
	
	return bg, stars


eps = 1.0 / 65536.0
img16 = tifffile.imread(args.infile)
img16 = np.atleast_3d(img16)
h, w, channels = img16.shape
	
col = [1,1,1,3,3][channels]
img16 = img16[:,:, 0:col]

img = np.array(img16[:,:, 0:col], np.float32)
img /= 65535.0

if args.sigma == 0.0:
	sigma = noise_level(img)
	print("sigma", sigma * 65535.0)

else:
	sigma = args.sigma / 65535.0


img[np.where(img < eps)] = eps


bw = np.mean(img, axis = 2)
edges = cv2.Sobel(bw, cv2.CV_64FC1, 1, 0, ksize = 3) ** 2 + cv2.Sobel(bw, cv2.CV_64FC1, 0, 1, ksize = 3) ** 2
weights = 1/ (1 + edges / (sigma * args.edges) ** 2)
#weight = cv2.GaussianBlur(weight, (5,5), 0)





#weights = np.ones((h,w), dtype=np.float64)


r,s = args.gf1
filt1 = None
if r > 0:
	filt1 = GuidedFilter(bw, r , (sigma * s) ** 2, weights)
	img = filt1.filter(img)
	img[np.where(img < eps)] = eps


if args.starproc:
	img, stars = separate_bg(img)

	stars = cv2.dilate(stars, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3)))
	stars = cv2.erode(stars, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5)))
	img += stars



#img = img - bg * 0.5

img[np.where(img < args.zero / 65535.0 + eps)] = args.zero / 65535.0 + eps

img[np.where(img < eps)] = eps

r,s = args.gf2
filt2 = None
if r > 0:
	filt2 = GuidedFilter(np.mean(img, axis = 2), r, (sigma * s) ** 2, weights)


img -= args.zero / 65535.0


img[np.where(img < eps)] = eps


if args.outgamma > 0:
	img = (img + sigma * args.sigmaeps) ** args.outgamma
	minval = (sigma * args.sigmaeps) ** args.outgamma
	maxval = 0
else:
	img = np.log(img + sigma * args.sigmaeps)
	minval = np.log(sigma * args.sigmaeps)
	maxval = np.log(1.0)

if filt2 is not None:
	img = filt2.filter(img)


if args.normalize:
	bg = cv2.dilate(img, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5)))
	minbg = np.min(bg)

	img[np.where(img<minbg)] = minbg
	img = cv2.normalize(img, img, alpha = 0, beta = 65535, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_16UC3)
else:
	img = cv2.divide((img - minval), tuple([(maxval - minval) / 65535.0] * 4), dtype=cv2.CV_16UC3)
	print("minval", minval, "maxval", maxval)

if args.outfile is not None:
	tifffile.imsave(args.outfile, img)

