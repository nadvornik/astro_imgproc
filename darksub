#!/usr/bin/python3

# Copyright (C) 2017 Vladimir Nadvornik
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

import numpy as np
import cv2

import tifffile
import argparse
import sys
from astro_utils import rawread, normalize, debayer, hp_filt_bayer, hp_filt_rgb, poly_bg, fit_images, combine_images


def apply_flat(img, flats, coefs):
	flat = np.zeros(img.shape, dtype=np.float32)
	for i, f in enumerate(flats):
		f = np.array(f, dtype=np.float32)
		flat += f * coefs[i]
			
	flat_bl_b = cv2.blur(flat[0::2, 0::2], (100, 100))
	flat_bl_r = cv2.blur(flat[1::2, 1::2], (100, 100))
	flat_bl_g1 = cv2.blur(flat[0::2, 1::2], (100, 100))
	flat_bl_g2 = cv2.blur(flat[1::2, 0::2], (100, 100))
	
	max_b = np.amax(flat_bl_b)
	max_g = (np.amax(flat_bl_g1) + np.amax(flat_bl_g2)) / 2.0
	max_r = np.amax(flat_bl_r)
	
	flat[np.where(flat == 0)] = 1
	mulmat = np.empty_like(flat)
	mulmat[0::2, 0::2] = max_b / flat[0::2, 0::2]
	mulmat[1::2, 1::2] = max_r / flat[1::2, 1::2]
	mulmat[0::2, 1::2] = max_g / flat[0::2, 1::2]
	mulmat[1::2, 0::2] = max_g / flat[1::2, 0::2]
	return cv2.multiply(img, mulmat, dtype=cv2.CV_32FC1)

def hotpix_find(img):
	img_hp = hp_filt(img, size = 3)
	mean, stddev = cv2.meanStdDev(img_hp)
	print(mean, stddev)

	hotpix_cnt = np.zeros_like(img, dtype=np.uint8)
	
	print(hotpix_cnt.shape, img.shape)
	hotpix_cnt[np.where(np.abs(img_hp) > stddev * 10)] += 100
	cv2.imwrite("hotpix.tif", hotpix_cnt)
	


parser = argparse.ArgumentParser()
parser.add_argument("infile",
                    help="input tiff file")
parser.add_argument("--outfile",
                    help="output tiff file")
parser.add_argument("--outbayer",
                    help="output tiff file before debayer")
parser.add_argument("--outrgb", nargs=3,
                    help="output tiff files for R, G, B")
parser.add_argument("--flat", nargs='*',
                    help="flat tif")
parser.add_argument("--dark", nargs='*',
                    help="dark tif")

parser.add_argument('--poly-bg', type=int, default = 0,
                   help='order of background polynom')

parser.add_argument('--scale', type=int, default = 4,
                   help='downscale')
parser.add_argument('--erode', type=int, default = 0,
                   help='erode')
parser.add_argument('--iter', type=int, default = 10,
                   help='iterations')

parser.add_argument('--min', type=int,
                   help='min value')
parser.add_argument('--max', type=int,
                   help='max value')

parser.add_argument('--zero', type=int, default = 0,
                   help='output zero level')

parser.add_argument("--dark-bg", action='store_true', default=False)
parser.add_argument("--flat-bg", action='store_true', default=False)
args = parser.parse_args()

if args.outrgb is None and args.outfile is None and args.outbayer is None:
	print("missing output")
	sys.exit(1)

minval = args.min
maxval = args.max

np.set_printoptions(edgeitems = 5)

img = rawread(args.infile)

if maxval is None:
	maxval = np.amax(img)

dark = []
if args.dark:
	for d in args.dark:
		dark.append(rawread(d))

if len(dark) > 0 and minval is None:
	minval = int(np.median(dark))

if minval is None:
	minval = int(np.amin(img))
	
print("min: %d, max:%d" % (minval, maxval))
	
#print img
img_hp = hp_filt_bayer(img)

dark_hp = []
for d in dark:
	dark_hp.append(hp_filt_bayer(d))

if len(dark) > 0:
	coefs, n = fit_images(dark_hp, img_hp, 10)

	final_dark = combine_images(dark, coefs, [minval] * len(dark))

	print("dark", np.median(final_dark))
	img = cv2.subtract(img, final_dark, dtype = cv2.CV_32FC1)
	#hotpix_find(final_dark)

if args.outbayer is not None:
	img = np.array(img, dtype=np.uint16)
	tifffile.imsave(args.outbayer, img)
	exit(0)


img = cv2.subtract(img, minval)

flat = []
if args.flat:
	for d in args.flat:
		f = rawread(d)
		f = cv2.subtract(f, minval)
		flat.append(f)

if len(flat) > 0:
#	img_hp = hp_filt_rgb(np.array(img, dtype=np.uint16))

#	flat_hp = [[], [], []]
#	for f in flat:
#		flat_hp_rgb = hp_filt_rgb(f)
#		for c in range(0,3):
#			flat_hp[c].append(flat_hp_rgb[c])

#	coefs = np.zeros((len(flat),))
#	for c in range(0,3):
#		print("fit", c)
#		coefs_c, n = fit_images(flat_hp[c], img_hp[c], 10, kappa = 3)
#		coefs += coefs_c / coefs_c.sum()

	img_hp = cv2.pyrDown(img)
	img_hp -= cv2.GaussianBlur(img_hp, (15,15), 0) * 0.9
	flat_hp = []
	for f in flat:
		hpf = cv2.pyrDown(np.array(f, dtype = np.float32))
		hpf -= cv2.GaussianBlur(hpf, (15,15), 0) * 0.9
		flat_hp.append(hpf)
	coefs, n = fit_images(flat_hp, img_hp, 10, kappa = 3)


	print(coefs)
	
	img = apply_flat(img, flat, coefs)
	print(img.shape)
		

img = cv2.multiply(img, 65535.0 / float(maxval - minval), dtype = cv2.CV_16UC1)

#col = cv2.cvtColor(img, cv2.COLOR_BAYER_BG2RGB)
col = debayer(img, filt = True)

if args.poly_bg > 0:
	bg_img = []

	if len(dark) > 0  and args.dark_bg:
		bg_img = bg_img + dark

	
	if len(flat) > 0  and args.flat_bg:
		bg_img = bg_img + flat
		
	for i in range(len(bg_img)):
		df = np.array(bg_img[i], dtype=np.float32)
		df = cv2.blur(df, (50,50))
		df = cv2.blur(df, (50,50))
		df = cv2.blur(df, (50,50))
		bg_img[i] = df
	
	bg = poly_bg(col, order = args.poly_bg, scale = args.scale, erode = args.erode, it = args.iter, darkframes = bg_img)
	bg -= args.zero
	col = cv2.subtract(col, bg, dtype = cv2.CV_16UC3)
else:
	col = cv2.add(col, (args.zero, args.zero, args.zero, 0), dtype = cv2.CV_16UC3)

if args.outfile is not None:
	tifffile.imsave(args.outfile, col)

if args.outrgb is not None:
	for i in range(0, 3):
		tifffile.imsave(args.outrgb[i], col[:, :, i])
