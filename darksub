#!/usr/bin/python3

# Copyright (C) 2017 Vladimir Nadvornik
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

import numpy as np
import cv2

import tifffile
import argparse
import sys
from astro_utils import rawread, normalize, debayer, hp_filt, poly_bg, fit_images, combine_images


def apply_flat(img, flats, exps):
	flat = np.ones(img.shape, dtype=np.float32)
	for i, f in enumerate(flats):
		f = np.array(f, dtype=np.float32)
		flat *= f ** exps[i]
			
	flat_bl_b = cv2.blur(flat[0::2, 0::2], (100, 100))
	flat_bl_r = cv2.blur(flat[1::2, 1::2], (100, 100))
	flat_bl_g = cv2.blur(flat[0::2, 1::2] + flat[1::2, 0::2], (100, 100)) / 2.0
	
	max_b = np.amax(flat_bl_b)
	max_g = np.amax(flat_bl_g)
	max_r = np.amax(flat_bl_r)
	
	flat[np.where(flat == 0)] = 1
	mulmat = np.empty_like(flat)
	mulmat[0::2, 0::2] = max_b / flat[0::2, 0::2]
	mulmat[1::2, 1::2] = max_r / flat[1::2, 1::2]
	mulmat[0::2, 1::2] = max_g / flat[0::2, 1::2]
	mulmat[1::2, 0::2] = max_g / flat[1::2, 0::2]
	return cv2.multiply(img, mulmat, dtype=cv2.CV_32FC1)

def hotpix_find(img):
	img_hp = hp_filt(img, size = 3)
	mean, stddev = cv2.meanStdDev(img_hp)
	print(mean, stddev)

	hotpix_cnt = np.zeros_like(img, dtype=np.uint8)
	
	print(hotpix_cnt.shape, img.shape)
	hotpix_cnt[np.where(np.abs(img_hp) > stddev * 10)] += 100
	cv2.imwrite("hotpix.tif", hotpix_cnt)
	


parser = argparse.ArgumentParser()
parser.add_argument("infile",
                    help="input tiff file")
parser.add_argument("--outfile",
                    help="output tiff file")
parser.add_argument("--outbayer",
                    help="output tiff file before debayer")
parser.add_argument("--outrgb", nargs=3,
                    help="output tiff files for R, G, B")
parser.add_argument("--flat", nargs='*',
                    help="flat tif")
parser.add_argument("--dark", nargs='*',
                    help="dark tif")

parser.add_argument('--poly-bg', type=int, default = 0,
                   help='order of background polynom')

parser.add_argument('--scale', type=int, default = 4,
                   help='downscale')
parser.add_argument('--erode', type=int, default = 0,
                   help='erode')
parser.add_argument('--iter', type=int, default = 10,
                   help='iterations')

parser.add_argument('--min', type=int,
                   help='min value')
parser.add_argument('--max', type=int,
                   help='max value')

parser.add_argument('--zero', type=int, default = 0,
                   help='output zero level')

parser.add_argument("--dark-bg", action='store_true', default=False)
parser.add_argument("--flat-bg", action='store_true', default=False)
args = parser.parse_args()

if args.outrgb is None and args.outfile is None and args.outbayer is None:
	print("missing output")
	sys.exit(1)

minval = args.min
maxval = args.max

np.set_printoptions(edgeitems = 5)

img = rawread(args.infile)

if maxval is None:
	maxval = np.amax(img)

dark = []
if args.dark:
	for d in args.dark:
		dark.append(rawread(d))

if len(dark) > 0 and minval is None:
	minval = int(np.median(dark))

if minval is None:
	minval = int(np.amin(img))
	
print("min: %d, max:%d" % (minval, maxval))
	
#print img
img_hp = hp_filt(img)

dark_hp = []
for d in dark:
	dark_hp.append(hp_filt(d))

if len(dark) > 0:
	coefs, n = fit_images(dark_hp, img_hp, 10)

	final_dark = combine_images(dark, coefs, [minval] * len(dark))

	print("dark", np.median(final_dark))
	img = cv2.subtract(img, final_dark, dtype = cv2.CV_32FC1)
	#hotpix_find(final_dark)

if args.outbayer is not None:
	img = np.array(img, dtype=np.uint16)
	tifffile.imsave(args.outbayer, img)
	exit(0)


img = cv2.subtract(img, minval)

flat = []
if args.flat:
	for d in args.flat:
		f = rawread(d)
		f = cv2.subtract(f, minval)
		flat.append(f)

if len(flat) > 0:
	l_f = []
	for f in flat:
		l_f.append(cv2.log(np.array(f, dtype=np.float64)))
		
	l_img = cv2.log(np.array(img, dtype=np.float64))
	#l_img = np.array(img, dtype=np.float64)
	
	
	flat_r = np.zeros_like(l_img)
	flat_r[1::2, 1::2] = 1
	
	flat_b = np.zeros_like(l_img)
	flat_b[0::2, 0::2] = 1
	
	flat_g = np.zeros_like(l_img)
	flat_g[0::2, 1::2] = 1
	flat_g[1::2, 0::2] = 1
	
	flat_rgb = [flat_r, flat_g, flat_b]
	
	
		
	exps, n = fit_images(l_f + flat_rgb, l_img, 10, kappa_plus = 3)
	
	img = apply_flat(img, flat, exps[:-3])
	print(img.shape)
		

img = cv2.multiply(img, 65535.0 / float(maxval - minval), dtype = cv2.CV_16UC1)

#col = cv2.cvtColor(img, cv2.COLOR_BAYER_BG2RGB)
col = debayer(img, filt = True)

if args.poly_bg > 0:
	bg_img = []

	if len(dark) > 0  and args.dark_bg:
		bg_img = bg_img + dark

	
	if len(flat) > 0  and args.flat_bg:
		bg_img = bg_img + flat
		
	for i in range(len(bg_mg)):
		df = np.array(bg_img[i], dtype=np.float32)
		df = cv2.blur(df, (100,100))
		df = cv2.blur(df, (100,100))
		df = cv2.blur(df, (100,100))
		bg_img[i] = df
	
	bg = poly_bg(col, order = args.poly_bg, scale = args.scale, erode = args.erode, it = args.iter, darkframes = bg_img)
	bg -= args.zero
	col = cv2.subtract(col, bg, dtype = cv2.CV_16UC3)
else:
	col = cv2.add(col, args.zero, dtype = cv2.CV_16UC3)

if args.outfile is not None:
	tifffile.imsave(args.outfile, col)

if args.outrgb is not None:
	for i in range(0, 3):
		tifffile.imsave(args.outrgb[i], col[:, :, i])
